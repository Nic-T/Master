# Asymmetric Cryptography & Protocols

We now shift from "shared secret" systems (Symmetric) to Public-Key Cryptography. This solves the key distribution problem: parties can communicate securely without having met beforehand to exchange a key.

## Core Concept: The Key Pair

Unlike symmetric systems (one key for everything), asymmetric systems use a mathematically related pair of keys:

- **Public Key:** Disseminated widely. Used to encrypt messages or verify signatures.
- **Private Key:** Kept secret. Used to decrypt messages or create signatures.
- **One-Way Trapdoor:** It must be computationally easy to generate the keys, but infeasible to derive the Private Key from the Public Key.

## The Main Algorithms

### 1. RSA (Rivest-Shamir-Adleman)

- **Security Basis:** Relies on the Integer Factorization Problem—the difficulty of factoring a large composite number $n$ into two large primes, $p$ and $q$.
- **Performance:** It is significantly slower (approx. 1000x) than symmetric algorithms like AES. Therefore, RSA is rarely used to encrypt actual files.
- **Hybrid Encryption:** In practice, RSA is used only to encrypt a small Session Key (e.g., an AES key). The actual data is then encrypted using that fast symmetric session key.

### 2. ECC (Elliptic Curve Cryptography)

- **Security Basis:** Relies on the discrete logarithm problem over elliptic curves ($y^2 = x^3 + ax + b$).
- **Advantage:** It offers equivalent security to RSA but with much smaller key sizes (e.g., a 256-bit ECC key ≈ 3072-bit RSA key), making it faster and more efficient for mobile devices.

## Key Protocols

### 1. Diffie-Hellman (DH)

- A protocol specifically for **Key Exchange**
- It allows two parties to agree on a shared secret over an insecure channel
- **Vulnerability:** It is vulnerable to Man-in-the-Middle (MITM) attacks if not authenticated (e.g., users must sign the exchange)

### 2. Digital Signatures

A digital signature is the cryptographic counterpart to a handwritten signature. It depends on the signer's secret (Private Key) and the message content.

#### Core Properties

- **Authentic:** The verifier knows who signed it.
- **Unforgeable:** Only the holder of the private key could create it.
- **Non-reusable:** The signature is a function of the document; it cannot be cut and pasted onto another file.
- **Unalterable:** If the signed document changes, the signature becomes invalid.
- **Non-repudiation:** The signer cannot later deny having signed the message (requires a Trusted Third Party to resolve disputes).

#### The Signing Process (Signature with Appendix)

Most modern schemes (like PGP or S/MIME) use a "Signature with Appendix" structure:

1. **Hash:** $H = Hash(Message)$
2. **Sign:** $Signature = Encrypt(H, Sender_{PrivateKey})$
3. **Send:** $\{Message, Signature\}$
4. **Verify:**
   - Calculate $H' = Hash(Message)$
   - Decrypt $H'' = Decrypt(Signature, Sender_{PublicKey})$
   - Check: If $H' == H''$, the signature is valid.

#### Key Algorithms

- **RSA Signature:** Uses the RSA inverse property. $S = m^d \pmod{n}$. Verification is $m = S^e \pmod{n}$. It allows "Message Recovery" (the signature contains the message).
- **DSA (Digital Signature Algorithm):** The US Government standard (FIPS 186). It is a variant of ElGamal and produces a signature of two 160-bit numbers $(r, s)$. It only works with a hash (Signature with Appendix).
- **ElGamal:** A randomized signature scheme based on Discrete Logarithms. Security relies on the difficulty of calculating discrete logs in finite fields.
- **ECDSA:** The Elliptic Curve version of DSA. Preferred for smaller key sizes and higher efficiency.

### 3. Zero-Knowledge Proofs (ZKP)

- A protocol where one party (the Prover) proves to another (the Verifier) that they know a secret without revealing the secret itself
- **Example:** The "Magic Door" or Ali Baba's Cave scenario. Alice proves she has the key to a door inside a cave by successfully exiting from the side Bob requests, without showing Bob the key.

## Public Key Infrastructure (PKI)

PKI solves the Man-in-the-Middle (MITM) attack. If Alice sends Bob her public key directly, an attacker could intercept it and send Bob a fake key. PKI introduces a Trusted Third Party (TTP) to vouch for the key.

### 1. The Certificate (X.509)

A digital ID card that binds an Identity to a Public Key:

- **Data Part:** Name (Alice), Public Key, Algorithm ID, Validity Dates.
- **Signature Part:** The Certification Authority (CA) signs the Data Part with the CA's Private Key.

### 2. PKI Components

- **CA (Certification Authority):** The "Root of Trust." Issues and signs certificates.
- **RA (Registration Authority):** Verifies the user's identity (e.g., checks a passport) before telling the CA to issue a certificate.
- **Repository:** A directory where certificates and CRLs are stored (often LDAP).
- **CRL (Certificate Revocation List):** A signed list of certificates that have been revoked before their expiration date (e.g., if a private key was stolen).

### 3. Trust Models

- **Hierarchical:** All trust flows down from a central Root CA (common in browsers/SSL).
- **Web of Trust:** Users sign each other's keys (used in PGP). There is no central authority; trust is decentralized.

### 4. Verifying a Certificate

When your browser verifies a website's certificate (Server Cert):

1. **Browser:** "I have the Root CA's Public Key pre-installed."
2. **Browser:** "I will decrypt the signature on the Server Cert using the Root CA's Public Key."
3. **Result:** "The signature matches. Therefore, the Server's Public Key inside this cert is authentic."

## Future Threats

### Quantum Computing

- A sufficiently powerful quantum computer running **Shor's Algorithm** could factor large integers rapidly, breaking RSA and ECC
- This has led to the current race for **Post-Quantum Cryptography (PQC)** standards (like CRYSTALS-Kyber)
