# Vocabulary and Foundations

## 1. The Core Objectives

1. ### Confidentiality

- It ensures that only authorized parties can read the data
- It is implemented using **Encryption**

2.  ### Integrity

- Guarantees that the data has not been altered or tampered with
- It does not hide the data
- It proves the data is authentic
- Usually implemented using **Hash Functions**

3. ### Authentication

- Verifies the identity of the parties involved **(Peer Entity Authentication)**
- Verifies the source of the data **(Data Origin Authentication)**
- Usually implemented using **MACs**

4. ### Non-repudiation

- Prevents someone from denying they performed an action (like sending a message)
- It is strictly implemented using **Digital Signatures**

5. ### Availability

- Ensures Data and services are accessible when needed
- Protects against Denial of Service (DoS) attacks
- Implemented via Redundancy, Backups, and Load Balancing

## 2. Security Models

1. ### Unconditional Security

- The key is truly random
- The key must be at least as long as the message
- The key must neber be reused
- The cipher cannot be broken, even with infinite computing power and time
- This can only achieved using **One-Time Pad (OTP)**

2. ### Computational Security

- The cipher can be broken, but it would take a long time or cost too much energy using current technology
- Modern algorithms like **AES** and **RSA** use this

3. ### Kerchkhoff's Principle

- The security of a cryptosystem must lie in entirely in the secrecy of the key, not the algorithm
- The algorithm should be public and analyzed by the community
- Always assume the attacker knows exactly how your system works

## 3. Mathematical Concepts

1. ### XOR (Exclusive OR)

- Most important operation in symmetric cryptography
- Often represente by this sign: ⊕
- Acts as a "toggle" and is reversible
- If you XOR a message with a key, and then XOR the result with a key again, you get the original message back

**Theory:** <br/>

It outputs 1 if the input bits are different. <br/>
It outputs 0 if the input bits are the same. <br/>
A⊕A=0 <br/>
M = Message, K = Key, C = Ciphertext <br/>
M⊕K=C,
C⊕K=M <br/>
You can swap two variables (A and B) without using a temporary third variable by XORing them three times: A=A⊕B; B=A⊕B; A=A⊕B

2. ### Entropy

- It measures the amount of randomness in a piece of data
- Password strengths can be calculated in bits using entropy (e.g., a coint toss has 1 bit of entropy)

**Theory:** <br/>
Calculating Entropy in Bits: The formula is H=log
2
​
(N), where N is the number of possible outcomes <br/>

Hexadecimal Character: There are 16 possibilities (0-9, A-F). log2(16)=4. A hex digit has 4 bits (a nibble) of entropy <br/>

8-Character Lowercase Password: There are 26 possibilities per character. Total combinations = 26^8

Calculation: 8×log2(26)≈8×4.7=37.6. <br/>
This password has roughly 37.6 bits of entropy <br/>

128-bit Key: If a key is generated by a truly random source (like atmospheric noise), it has 128 bits of entropy. If it is derived from a user password like "password123", it might look 128-bits long, but it has extremely low entropy (easy to guess)

3. ### Modulo Operator

- Also called "clock arithmetic"
- It ensures the results stay within a fixxed margin
- Crucial for finite fields in **AES** and **RSA**


4. ### Nonce (Number used ONCE)

- A random or pseudo-random number issued in an authentication protocol to ensure that old communications cannot be reused in replay attacks.
- **CRITICAL RULE:** A nonce must **NEVER** be reused with the same key.
- **Uses:**
    - **Initialization Vector (IV):** In CBC/CTR modes to ensure unique ciphertexts for identical messages.
    - **Challenge-Response:** Server sends a nonce to Client; Client signs it. Proves Client is "live" and not a recording.
    - **Blockchain:** Used in Proof of Work (mining).
- **Analogy:** Like a "timestamp" but without needing a synchronized clock. It marks a message as "fresh".

## 4. Important Distinctions

1. ### Steganography vs. Cryptography

- Steganography is the art of hiding the existance of a message (e.g., inside an image)
- Cryptography scrambles the message so it cannot be read

2. ### Encoding vs. Encryption

- Encoding (like Base64 or Hex) is for data usability and is easily reversible by anyone
- Encryption requires a secret key to reverse

## 5. Threat Models & Attacks

1. ### The Dolev-Yao Model

- A mathematical model for analyzing protocols
- **Assumption:** The attacker has full control over the communication network
- The attacker can: Read, Copy, Delete, Modify, and Replay any message
- **Conclusion:** Never trust the communication channel

2. ### Passive Attacks

- The attacker listens without altering data (e.g., Eavesdropping, Traffic Analysis)
- Hard to detect
- Aimed at confidentiality

3. ### Active Attacks

- The attacker alters system operations (e.g., Tampering, Replay, Man-in-the-Middle)
- A Nonce (Number used ONCE) or a Timestamp is the primary defense against Replay attacks.

4. ### Ciphtertext-only

- The Attacker has only the encrypted "garbage"

5. ### Known-plaintext

- The Attacker has a sample of plaintext and its matching ciphertext

6. ### Chosen-plaintext

- The Attacker can feed specific text into the system to see the encrypted result
